<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>总找外国男友的女生A</title>
    <link href="/2021/06/15/%E6%80%BB%E6%89%BE%E5%A4%96%E5%9B%BD%E7%94%B7%E5%8F%8B%E7%9A%84%E5%A5%B3%E7%94%9FA/"/>
    <url>/2021/06/15/%E6%80%BB%E6%89%BE%E5%A4%96%E5%9B%BD%E7%94%B7%E5%8F%8B%E7%9A%84%E5%A5%B3%E7%94%9FA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：我离开澳大利亚这个国家已有一年有余，在那地时，只觉是平常生活，如今将要与这个国家彻底断开联系，有些碎碎念却不自觉的流露而出。大家好，我叫Sean（肖恩），我在澳大利亚度过了一年多学业生涯。这是我的回忆录，我相信与人之间的缘分，那就先从人物篇开始吧！</p></blockquote><h1 id="为什么是她？"><a href="#为什么是她？" class="headerlink" title="为什么是她？"></a>为什么是她？</h1><p>这我的第一篇回忆录，她不是我在澳洲一年多中遇到过最重要的人，但是她确实是第一个给我带来认知上强烈冲击的人。</p><p>我的朋友们经常如此评价我</p><p>“你大概可以跟任何人成为朋友吧”。</p><p>我想也是，我的原生家庭给我灌输了大量中庸，沉默，吃亏是福的思想。而我大学学习的是社会学与社会工作，我可能更加理解一些如何与人相处。除非那个人<strong>明确地</strong>打破了我的底线。而这个女生几乎是一只脚踏入了当中。</p><h1 id="宝岛人与宝岛情节"><a href="#宝岛人与宝岛情节" class="headerlink" title="宝岛人与宝岛情节"></a>宝岛人与宝岛情节</h1><p>她是一个纯正的大陆人，身边却总有一群台湾人。</p><p>初次从同学变成朋友，是帮她搬家。本以为只是一场平常的体力活，没想到她的室友们都是台湾人，即将新搬进来的室友也是台湾人。这对我来说可是新鲜事，毕竟以前都是在电视上和网络上看到台湾人。新搬进来的室友的父母也在，看上去也有50岁左右了，他们知道我们都是大陆人之后也感到很新鲜，便和我们聊了起来。唯独那些年轻人们闭而不语，仿佛我们之间隔着一道墙。</p><p>当然，此时还未有什么轩然大波，自始至终也没有。搬家的一天也很快过去，而语言班也很快过去。语言班分别之后，我们的联系就不似以前那么频繁。当然这种减少多多少少是与那件事有关的。</p><h2 id="唐突的发言"><a href="#唐突的发言" class="headerlink" title="唐突的发言"></a>唐突的发言</h2><p>那一阵子局势有些紧张，不论是国际上还是地区上。每当这时候，火药味总是十足，平时笑脸相迎的“朋友”说不定都会瞬间撕破脸皮。</p><p>听说她又交了几个台湾朋友，还有一个关系特别好，闺蜜级别的。一天语言班课后的同学聚会，结束后我们顺路就坐了一版公交车。“唉，天天争论不休，早点统一多好”我在车上突然冒出这么一句。她愣了一下，突然抬头盯着我用特别差异的眼神问：“什么统一。。。。。。哎？你，你在说什么啊？”我想我这没头没尾的一句也是挺唐突，便说：“台湾啊，最近不是一直在吵这个事。”然而我的解释让她更诧异了，她头先向后转了一下，又迅速转回来挤出一句：“哎！你在说什么啊”她低下头避开了目光对视，“什么统一啊，他自己在那好好的”，顿了一下，她好像还想说什么，但是看到我略显严肃的脸她也没再向下说，可能也是一时间没有组织起语言。我也没有再说什么，脸上挂着淡淡的微笑，心里却翻了个180度。过去我曾想过许多这种面对这类人的态度，言辞和行为，但是此时此刻我却不知道说些什么。今天我们还在一起讨论问题，分配小组作业，八卦其他同学。但是我知道此时此刻一定是我们关系的转向标了。</p><p>我迅速平复了一下心情，她既然没有继续向下说，那就让我们略微保持一下这表面的“友谊”吧。</p><h1 id="外国男友们"><a href="#外国男友们" class="headerlink" title="外国男友们"></a>外国男友们</h1>]]></content>
    
    
    <categories>
      
      <category>澳洲回忆录</category>
      
      <category>人物篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>澳洲回忆录 （人物篇）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2021/06/13/Promise/"/>
    <url>/2021/06/13/Promise/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：Promise是ES6为JavaScript新增的一个异步编程模式。一经问世，它的强大之处就获得了广泛的关注和赞许。Promise的用法简单易懂，但是当我们尝试深挖其实现原理和浏览器对其执行机制时，常常会感到难以理解或者会发生意想不到的事。本文就来剖析Promise及其实现原理。</p></blockquote><h1 id="1-什么是异步编程"><a href="#1-什么是异步编程" class="headerlink" title="1. 什么是异步编程"></a>1. 什么是异步编程</h1><p>简单来说，在JavaScript里，异步编程就是将那些计算量大或者耗时长的任务放入另一队列中，以防止这些任务阻塞主任务的操作。JavaScript是单线程事件循环模型，这意味着它只能够按照脚本的编辑顺序从上到下依次执行语句，当遇到了异步任务，它会将异步任务依次推入异步任务事件队列，当所有同步任务和微任务执行完毕，才会从队列中取出异步任务依次执行。</p><p>在ES5时，异步编程模式为使用回调函数。例如计时器：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>其中的function函数就是回调函数</p><h1 id="2-为什么要使用Promise"><a href="#2-为什么要使用Promise" class="headerlink" title="2. 为什么要使用Promise"></a>2. 为什么要使用Promise</h1><p>这主要是因为回调函数有一个难以回避的缺点，就是<em><strong>“回调地狱”</strong></em>。即嵌套回调，当一个回调函数需要的值由另一个回调函数返回时，就会发生这种情况，而在现实开发中，这种情况很常见。这么做的缺点有：</p><ul><li>耦合度高</li><li>可复用性差</li><li>可阅读性差</li><li>可扩展性差</li><li>不好处理错误</li></ul><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="3-使用Promise"><a href="#3-使用Promise" class="headerlink" title="3. 使用Promise"></a>3. 使用Promise</h1><p>于是，ES6就推出了Promise (期约)。让我们先看一看它是如何使用的：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> rejected</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>resolve <span class="token operator">+</span> <span class="token string">"ok"</span><span class="token punctuation">)</span> <span class="token comment">// "okok"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"ok2"</span><span class="token punctuation">)</span>          <span class="token comment">// "ok2"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">/*-------------------------------------------*/</span><span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> rejected</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">rejected</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rejected <span class="token operator">+</span> <span class="token string">"fail"</span><span class="token punctuation">)</span> <span class="token comment">// </span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">rejected</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span>          <span class="token comment">// fail</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><strong>乍一看上去很复杂，这都是什么啊！不要着急，让我们一步一步来探究promise！</strong></p><ul><li>首先，我们需要实例化一个<code>Promise</code>对象。</li><li>很明显，我们能够看出，这个<code>Promise</code>需要传入一个回调函数作为参数。而这个回调函数需要传入两个参数，第一个是成功，第二个是失败。而这个函数内部执行了一个<code>resolve(&quot;ok&quot;)</code>或者<code>rejected(&quot;fail&quot;)</code>, 这是在决定这个Promise最终的结果是成功还是失败。当然函数内部也可以执行其他语句，但是一定要在<strong>决定状态之前执行</strong>。</li><li>接着就是Promise后面紧跟的<code>.then()</code>, 这就是用来处理成功或者失败后结果的方法。then里面同样传入一个回调函数作为参数。回调函数同样有两个参数，一个为成功回调函数，另一个为失败回调函数。当promise本体确定为成功状态时，then方法里回调函数的成功参数则能获取到成功的传值。失败状态也同样适用。</li><li>而catch方法则只用来处理失败状态，它只有一个参数<code>rejected</code></li></ul><h1 id="3-解决回调地狱问题"><a href="#3-解决回调地狱问题" class="headerlink" title="3. 解决回调地狱问题"></a>3. 解决回调地狱问题</h1><p>Promise的基本原理已经明白了，那它是如何解决回调地狱的问题呢？如我们来看看！</p><h2 id="3-1-链式调用"><a href="#3-1-链式调用" class="headerlink" title="3.1 链式调用"></a>3.1 链式调用</h2><p>回调地狱的主要问题是回调函数嵌套。而Promise则是适用then方法的链式调用处理这个问题。即不管有多少回调函数需要嵌套，只需要新增一个then方法，跟在上一个then后面即可。</p><p>Promise之所以可以这么做，是因为<strong>每一个then方法内部都返回了一个新的Promise对象。</strong></p><h2 id="3-2-异常穿透"><a href="#3-2-异常穿透" class="headerlink" title="3.2 异常穿透"></a>3.2 异常穿透</h2><p>同时，我们刚刚也谈及了回调地狱难以处理错误的情况。那Promise是如何解决的呢？事实上，不管Promise后面跟着多少<code>then</code>方法，我们只可以在<code>then</code>方法里执行成功回调函数，而在最后接上一个<code>catch</code>方法来处理错误。一旦Promise本身的状态变成错误，它就会越过中间所有的then方法中的成功回调函数去执行最后的catch错误处理。</p><p>另外，如果中间有<code>then</code>方法抛出了错误，同样会越过下面所有的成功回调，去执行最后的错误回调函数。这就是Promise的异常穿透特性。</p><h1 id="4-特性及优缺点"><a href="#4-特性及优缺点" class="headerlink" title="4. 特性及优缺点"></a>4. 特性及优缺点</h1><h2 id="4-1-Promise特性"><a href="#4-1-Promise特性" class="headerlink" title="4.1 Promise特性"></a>4.1 Promise特性</h2><ul><li>Promise的状态有待定<code>pending</code>，成功<code>fullfilled</code>，失败<code>rejected</code>三种，状态之间只能由刚实例化时的待定转向成功或者待定转向失败。<strong>没有第三种可能</strong>！</li><li>Promise的状态一旦确定，无法逆转，无法撤销。</li></ul><h2 id="4-2-优缺点"><a href="#4-2-优缺点" class="headerlink" title="4.2 优缺点"></a>4.2 优缺点</h2><p>Promise的优点就是解决了回调地狱带来的问题。</p><p><strong>缺点</strong>：</p><ul><li>状态一旦确定无法逆转无法撤销</li><li>Promise的执行过程不能取消</li><li>不能读取异步过程的进度</li><li>错误仍然需要在回调函数中获取</li></ul><h1 id="5-Promise的其他方法"><a href="#5-Promise的其他方法" class="headerlink" title="5. Promise的其他方法"></a>5. Promise的其他方法</h1><ul><li><p><code>.finally</code> 不过状态是成功还是失败，不管中间经历了多少<code>then</code>方法回调，等待上面的全部执行完成之后，<code>finally</code>里的回调函数一定会执行。</p></li><li><p><code>Promise.all </code>传入一组promise实例，<strong>只有当所有实例都成功</strong>，这个<code>all</code>的新promise才进入成功状态，否则失败。</p></li><li><p><code>Promise.race</code> 传入一组promise实例，这个<code>race</code>的新promise的状态就是<strong>内部第一个产生状态</strong>的promise的实例的状态。</p></li><li><p><code>Promise.any</code> 传入一组promise实例，<strong>只要有一个promise成功了</strong>，这个<code>any</code>的新promise的状态为成功。否则失败。</p></li><li><p><code>Promise.allsettled </code> 传入一组promise实例，当所有promise有结果后，<strong>不管成功还是失败</strong>，这个<code>allsettled</code>的新promise进入成功状态。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>JavaScript高级程序设计（第四版）<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>JavaScript</category>
      
      <category>基础概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript继承</title>
    <link href="/2021/06/10/JavaScript%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/06/10/JavaScript%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：继承是面向对象编程中最常讨论的话题。我们在进行构造函数的时候，为了避免在有创造相关的构造函数或者定义子类时重复定义一些属性和方法，我们就会用到继承。即子构造函数继承父构造函数的属性和方法。这样降低了耦合度，增加了扩展性和可复用性，也增加了代码的简洁性和可阅读性。</p></blockquote><h1 id="1-ES6中的继承"><a href="#1-ES6中的继承" class="headerlink" title="1. ES6中的继承"></a>1. ES6中的继承</h1><p>ES6中不管是继承属性还是继承方法都非常简单</p><p>我们只需要使用extends和super方法即可</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Children</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span> title</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="2-ES5中的继承"><a href="#2-ES5中的继承" class="headerlink" title="2. ES5中的继承"></a>2. ES5中的继承</h1><h2 id="2-1-组合式继承"><a href="#2-1-组合式继承" class="headerlink" title="2.1 组合式继承"></a>2.1 组合式继承</h2><p>而在ES5中，我们可以使用基础的组合式继承。即分别继承属性和继承方法</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Children</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span> title</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span>          <span class="token comment">// 继承属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">&#125;</span><span class="token class-name">Children</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 继承方法</span><span class="token class-name">Children</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Children<span class="token punctuation">;</span> <span class="token comment">// 改变构造器指向</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="2-2-寄生式组合继承"><a href="#2-2-寄生式组合继承" class="headerlink" title="2.2 寄生式组合继承"></a>2.2 寄生式组合继承</h2><p>组合式继承简单易懂却有着一个<strong>明显的缺点</strong>。那就是在<strong>继承方法</strong>的时候父类构造函数被<strong>调用了两次</strong>。<strong>一次是继承方法是，另一次是实例化子构造函数时</strong>，这消耗了一定资源。为了作进一步优化，我们可以使用一种寄生式组合继承</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>               <span class="token comment">// 定义寄生函数</span><span class="token keyword">function</span> <span class="token function">Children</span><span class="token punctuation">(</span><span class="token parameter">age<span class="token punctuation">,</span> title</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span>          <span class="token comment">// 继承属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">&#125;</span>fn<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 寄生函数与父构造函数原型链绑定</span><span class="token class-name">Children</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 从寄生函数继承方法</span><span class="token class-name">Children</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Children<span class="token punctuation">;</span> <span class="token comment">// 改变构造器指向</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="3-继承的原理"><a href="#3-继承的原理" class="headerlink" title="3. 继承的原理"></a>3. 继承的原理</h1><p>继承的原理其实就是用到了原型和原型链。构造函数和其实例在调用属性和方法时，都会沿着原型链向上查找，其顺序为：</p><ul><li>先在自己身上查找对应属性和方法，有就直接调用，并停止查找。</li><li>去自己的构造函数上查找对应的属性和方法。</li><li>沿着原型链向上查找，一直会找到Object的原型对象</li><li>再向上就是null了。就会报错查找不到。</li></ul><p>继承就是进行了原型链的绑定。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>JavaScript高级程序设计（第四版）<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>JavaScript</category>
      
      <category>基础概念</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖和节流</title>
    <link href="/2021/06/09/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <url>/2021/06/09/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：防抖和节流是前端开发中重要的两个概念，但是其概念与其名称一样，没有浅显易懂。防抖和节流是两个不同的功能，都用于限制用户的频繁操作和资源请求，减轻服务器的压力，是前端开发中重要的性能优化方法。下面就让我们探究一下防抖和节流吧。</p></blockquote><h1 id="1-防抖（debounce）"><a href="#1-防抖（debounce）" class="headerlink" title="1. 防抖（debounce）"></a>1. 防抖（debounce）</h1><h2 id="1-1-什么是防抖"><a href="#1-1-什么是防抖" class="headerlink" title="1.1 什么是防抖"></a>1.1 什么是防抖</h2><p>让我们用一个例子来认识防抖：</p><p class="note note-info"><strong>需求</strong> <br/> 用户在搜索框中输入内容之后，在下拉框中显示输入内容相关的信息</p><p>那么，很显然，这需要获取用户输入的字符，然后以该字符向服务器发送请求，服务器返回与该字符相关的信息。</p><p><strong>但是，我们需要在用户每输入一个字符就发送一次请求吗？</strong>这显然是不合理的，如果用户数量大，那么服务器将不堪重负。</p><p>我们就需要一点点优化，在用户输入一个字符的未来一段时间内，只要用户持续输入内容，就不发送请求。这时候就需要<strong>“防抖”</strong>，即在这规定的时间内，只有用户持续输入内容，<strong>发送请求的行为就会被打断，规定时间需要重新计时</strong>。这就像是游戏中的“吟唱读条“，在吟唱过程中如果受到了打断，吟唱则需要重头开始。</p><h2 id="1-2-如何实现防抖"><a href="#1-2-如何实现防抖" class="headerlink" title="1.2 如何实现防抖"></a>1.2 如何实现防抖</h2><p>那么如何实现防抖呢？刚刚提到了计时的概念，那很显然需要用到<strong>定时器</strong>。让我们直接看代码：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>           <span class="token comment">// 闭包返回函数</span>        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span>              <span class="token comment">// 保存this</span>        timer <span class="token operator">&amp;&amp;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>    <span class="token comment">// 清除定时器</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>        <span class="token comment">// 设置定时器</span>    <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token comment">// 绑定this指向和传参</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li><p>首先，我们需要为防抖函数传入要执行的函数并设定一个延迟时间。并且用<strong>闭包</strong>的形式将里面的被定时器包裹的函数返回。这是因为我们触发事件需要的是这个内部函数，而不是外面的防抖函数。</p></li><li><p>设置定时器，并将执行函数放进去。为了达到防抖效果，需要在执行函数前<strong>消除定时器</strong>，这样在用户每次执行事件时，定时器就会重新计时。</p></li><li><p>考虑定时器内部<strong>this指向</strong>问题，需要在外部用一个变量保存this，在定时器内部用call绑定。</p></li><li><p>考虑执行函数的<strong>参数传入</strong>问题。使用剩余参数在call绑定this指向时一并传入。</p></li></ol><h2 id="1-3-第一次执行"><a href="#1-3-第一次执行" class="headerlink" title="1.3 第一次执行"></a>1.3 第一次执行</h2><p>以上就是基本的防抖函数了，但是它有一个问题，那就是在用户第一次执行事件时，它就会起到一个“防抖”的效果，这在一些场合是我们不希望看见的。于是，我们需要考虑一下如何让函数在第一次事件中能够立刻执行。</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debouceImme</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timer<span class="token punctuation">;</span>        timer <span class="token operator">&amp;&amp;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>            timer <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>        callNow <span class="token operator">&amp;&amp;</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>使用了一个<code>callNow</code>限制了函数的执行，只有当timer被清除，<code>callNow</code>才为真，函数才执行。</li><li>而定时器的作用缺变成了将自身清除，而不是限制函数的执行。这样与<code>callNow</code>结合后，在计时器计时期间，<code>callNow</code>始终不为真，函数就无法执行，起到了防抖的作用</li><li>而第一次执行时，timer被定义成null，所以函数可以直接执行。</li></ul><h2 id="1-4-封装"><a href="#1-4-封装" class="headerlink" title="1.4 封装"></a>1.4 封装</h2><p>将以上两种情况都考虑并封装起来：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> immediate</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> timer<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        timer <span class="token operator">&amp;&amp;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> callNow <span class="token operator">=</span> <span class="token operator">!</span>timer            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>            timer <span class="token operator">=</span> <span class="token keyword">null</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>            callNow <span class="token operator">&amp;&amp;</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="2-节流（throttle）"><a href="#2-节流（throttle）" class="headerlink" title="2. 节流（throttle）"></a>2. 节流（throttle）</h1><h2 id="2-1-什么是节流"><a href="#2-1-什么是节流" class="headerlink" title="2.1 什么是节流"></a>2.1 什么是节流</h2><p>理解了防抖，拿什么是节流呢？还是用一个例子：</p><p class="note note-info"><strong>需求</strong> <br/> 用户使用手机验证码登录时，请求一次验证码之后要60s之后才能再次点击请求，考虑到一些需求，不能将按钮直接设置为disabled</p><p>同理，我们还是可以使用定时器来解决这个需求，<strong>即定时器只要在计时，这个函数就不会进入执行</strong>。不管用户在如何点击按钮也不会触发事件。这就像是游戏中技能的“冷却时间”，一个技能在释放完毕之后，要经过一段时间才能再次释放。</p><h2 id="2-2-如何实现节流"><a href="#2-2-如何实现节流" class="headerlink" title="2.2 如何实现节流"></a>2.2 如何实现节流</h2><p>直接上代码：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> timer<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token keyword">return</span>         timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>            timer <span class="token operator">=</span> <span class="token keyword">null</span>；        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>相对于上面的防抖，节流就很好理解了。在设置完定时器之后，只要这个定时器还在计时，重复执行这个时间都会触发<code>if(timer) return</code>直接返回。</li></ul><h2 id="2-3-第一次执行"><a href="#2-3-第一次执行" class="headerlink" title="2.3 第一次执行"></a>2.3 第一次执行</h2><p>同样，上面的节流函数在第一次执行事件就直接进入了计时。为了让第一次就能直接触发事件，我们需要使用新的思路来重新这个函数。</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">throttleimme</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">-</span> pre <span class="token operator">></span> delay<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>            pre <span class="token operator">=</span> now        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这里直接将定时器替换成简单的时间减算。</p><ul><li>首先第一次执行时，<code>now - pre</code>肯定大于延迟的值，则必定能进入内部执行函数</li><li>执行完函数后，将刚刚设置的<code>now</code>时间赋值给了<code>pre</code>，下次再点击时，又重新了设置<code>now</code>，新的<code>now</code>减去旧的<code>now</code>的到的时间就是上一次执行完时间后所过的时间，如果不够设置的间隔时间，是无法再次触发事件的。</li></ul><h2 id="2-4-封装"><a href="#2-4-封装" class="headerlink" title="2.4 封装"></a>2.4 封装</h2><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> delay<span class="token punctuation">,</span> imme</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>imme<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> timer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>imme<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">-</span> now <span class="token operator">></span> delay<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                pre <span class="token operator">=</span> now            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">&#123;</span>                <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li><p>当使用防抖函数时，内部的执行函数不能够加<code>( )</code>,否则函数会立刻执行</p></li><li><p>如果要传入参数，应当使用<code>debounce(func.bind(this, ...args), delay)</code></p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6844903651278848014#heading-0">函数防抖和节流</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>JavaScript</category>
      
      <category>性能优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型 - 深拷贝</title>
    <link href="/2021/06/08/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <url>/2021/06/08/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言：当对变量进行赋值操作时，往往会发现引用类型的变量直接赋值会导致多个引用类型共享同一值的问题。那我们就需要使用深拷贝对其进行赋值，避免出现以上问题。</p></blockquote><h1 id="1-什么是深拷贝"><a href="#1-什么是深拷贝" class="headerlink" title="1. 什么是深拷贝"></a>1. 什么是深拷贝</h1><p>深拷贝即为对深层嵌套引用类型的数据进行层内基础数据类型的赋值操作。以避免引用类型直接赋值带来的共享同一值的问题。例：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"lisi"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 'lisi'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p class="note note-warning"><strong>注意：</strong><br/> 我们改变了obj2的name，但是obj1的name也被改变了，为了避免这种问题，我们需要深拷贝</p><p>例如：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    obj2<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj1<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">&#125;</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"lisi"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 'zhangsan'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>这就是最简单的深拷贝，但是当引用类型里面还是引用类型时，比如对象里面还有对象，该方法还是没有用。</p><h1 id="2-如何进行深拷贝"><a href="#2-如何进行深拷贝" class="headerlink" title="2. 如何进行深拷贝"></a>2. 如何进行深拷贝</h1><h2 id="2-1-JSON"><a href="#2-1-JSON" class="headerlink" title="2.1 JSON"></a>2.1 JSON</h2><p>JSON有两个方法，一个方法是<code>json.stringify()</code>可以将一个对象转换成字符串，第二个方法为<code>json.parse()</code>可以将字符串转换成json对象。我们只需要将一个对象先转换成字符串再转换成对象，该对象就不会跟原来的对象指向共同的值了。</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    obj2 <span class="token operator">=</span> json<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"lisi"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 'zhangsan'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>成功了！<strong>但是</strong>，</p><p>该方法有诸多缺陷，例如会忽视掉引用类型里的symbol，null等数据，也不会转换函数方法，Date()，RegExp等。</p><h2 id="2-2-深层递归"><a href="#2-2-深层递归" class="headerlink" title="2.2 深层递归"></a>2.2 深层递归</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>简单的遍历赋值会失效是因为它只拷贝了一层，那么我们让它递归直到数据为基础类型就停止不就可以了吗</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> newObj    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> obj    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    obj2 <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"lisi"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 'zhangsan'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>成功了！<strong>但是</strong>，</p><p>引用类型只有对象吗？如果是数组该怎么办？那我们则需要加上对象判断，以下以区分数组和对象为例</p><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">let</span> newObj <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> newObj<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> obj<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span>name<span class="token operator">:</span><span class="token string">'zhangsan'</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    arr2 <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span>arr2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"lisi"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p class="note note-warning"><strong>注意</strong><br/> 该例子只判断了数组和对象，实际情况下还有很多需要单独判断，例如函数等</p><p>成功了！<strong>但是，</strong></p><p>我们使用递归会不会出现一些问题呢？是的，如果一个<strong>引用类型里面有引用到自己</strong>，那么递归就会<strong>爆栈</strong>，导致失败。为此，我们需要检测循环引用，使其闭环。</p><h3 id="闭环"><a href="#闭环" class="headerlink" title="闭环"></a>闭环</h3><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">let</span> newObj <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> newObj<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> newObj<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> obj<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>obj1<span class="token punctuation">.</span>o <span class="token operator">=</span> obj1<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span> <span class="token comment">// &#123;name: 'zhangsan', o: obj1&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>OK 这就是基本的深拷贝！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6844903929705136141#heading-5">如何写出一个惊艳面试官的深拷贝?</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>JavaScript</category>
      
      <category>数据类型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何解决跨域问题 - JSONP？</title>
    <link href="/2021/06/07/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
    <url>/2021/06/07/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言 ：为什么有跨域问题？</p><p>当客户端向服务器端请求数据的时候，如果两者不同源，即<strong>协议号，域名或者端口号有任一不一样</strong>，则<strong>浏览器</strong>为了安全起见将会拦截服务器端响应的数据。这就是同源政策。而JSONP则是一种打破同源政策的方法。</p></blockquote><h1 id="1-什么是JSONP"><a href="#1-什么是JSONP" class="headerlink" title="1. 什么是JSONP"></a>1. 什么是JSONP</h1><p>JSONP是 “JSON with padding” 的简写，是在Web服务上流行的一种JSON变体。</p><p>JSONP利用<code>&lt;script&gt;</code>标签没有跨域限制的漏洞，网页可以获得其他来源动态产生的JSON数据。后端将数据进行相应的转化就能绕开浏览器的同源政策，将数据发送给前端。这也意味着使用JSONP需要前端和后端共同支持。</p><h1 id="2-如何使用JSONP"><a href="#2-如何使用JSONP" class="headerlink" title="2. 如何使用JSONP"></a>2. 如何使用JSONP</h1><h2 id="2-1-实现流程"><a href="#2-1-实现流程" class="headerlink" title="2.1 实现流程"></a>2.1 实现流程</h2><ul><li>声明一个回调函数，该函数将作为请求参数和接受处理数据的重要工具。函数的形参为要获取目标数据。</li><li>动态创建一个<code>script</code>标签插入文本中。把跨域的API几口写在src属性上，并且将在后面拼接上<code>?callback=回调函数</code>的参数。</li><li>服务器端收到请求后，把传进来的函数名和他需要的数据拼接成一个字符串</li><li>最后服务器把准备的数据返回给客户端，客户端还是使用之前声明的回调函数对返回的数据进行操作。</li></ul><h2 id="2-2-封装一个JSONP"><a href="#2-2-封装一个JSONP" class="headerlink" title="2.2 封装一个JSONP"></a>2.2 封装一个JSONP</h2><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/* index.html */</span><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">&#123;</span>url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callback<span class="token punctuation">&#125;</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">creatElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>        window<span class="token punctuation">[</span>callback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        params<span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">...</span>params<span class="token punctuation">,</span> callback<span class="token punctuation">&#125;</span>        <span class="token keyword">let</span> arrs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> parmas<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arrs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>key<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        script<span class="token punctuation">.</span>src<span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>url<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>arrs<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'&amp;'</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    url<span class="token operator">:</span><span class="token string">'https://www.xxxxx.com:3000/name'</span><span class="token punctuation">,</span>    params<span class="token operator">:</span><span class="token punctuation">&#123;</span>age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    callback<span class="token operator">:</span><span class="token string">'show'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="2-2-服务器端实现"><a href="#2-2-服务器端实现" class="headerlink" title="2.2 服务器端实现"></a>2.2 服务器端实现</h2><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> urllib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token keyword">var</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'data'</span><span class="token operator">:</span><span class="token string">'world'</span><span class="token punctuation">&#125;</span>http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> params <span class="token operator">=</span> urllib<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span>query<span class="token punctuation">.</span>callback<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// jsonp</span>        <span class="token keyword">var</span> str <span class="token operator">=</span> params<span class="token punctuation">.</span>query<span class="token punctuation">.</span>callback <span class="token operator">+</span> <span class="token string">'('</span> <span class="token operator">+</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">;</span>        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'jsonp server is on'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="3-为什么要使用JSONP"><a href="#3-为什么要使用JSONP" class="headerlink" title="3. 为什么要使用JSONP"></a>3. 为什么要使用JSONP</h1><ul><li><p><strong>简单易用</strong>，解决了主流浏览器跨域数据访问的问题</p></li><li><p><strong>兼容性好</strong>，支持IE9以下浏览器</p></li></ul><h1 id="4-JSONP有什么缺点"><a href="#4-JSONP有什么缺点" class="headerlink" title="4. JSONP有什么缺点"></a>4. JSONP有什么缺点</h1><ul><li>JSONP仅支持get方法</li><li>安全系数不高，容易遭受XSS攻击</li><li>不好确定JSONP是否请求失败。开发者经常需要使用计时器来确认请求响应时间并决定是否放弃等待响应。但即使如此还是不准确，因为不同用户网络连接速度和带宽是不一样的</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://segmentfault.com/a/1190000007665361">jsonp的原理与实现</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理 (完整版)</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>前端网络</category>
      
      <category>跨域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全-XSS &amp; CSRF</title>
    <link href="/2021/06/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-XSS-CSRF/"/>
    <url>/2021/06/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-XSS-CSRF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言 ：XSS和CSRF是常见的网络安全问题，忽视它们可能为应用带来巨大的打击和损失。其中XSS名声在外，通常都会采取各种措施进行防护。而CSRF却经常被忽视，被认为攻击性没有XSS大。但两者可能造成的后果都是严重的。</p></blockquote><h1 id="1-Cross-Site-Scripting"><a href="#1-Cross-Site-Scripting" class="headerlink" title="1. Cross Site Scripting"></a>1. Cross Site Scripting</h1><h2 id="1-1-XSS是什么"><a href="#1-1-XSS是什么" class="headerlink" title="1.1 XSS是什么"></a>1.1 XSS是什么</h2><p>XSS攻击是<strong>跨站脚本攻击</strong>。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户信息，比如cookie等。这是因为网站没有对恶意代码进行过滤，与正常代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的。</p><h2 id="1-2-XSS有哪些类型"><a href="#1-2-XSS有哪些类型" class="headerlink" title="1.2 XSS有哪些类型"></a>1.2 XSS有哪些类型</h2><ul><li><strong>存储型（服务器）</strong>，恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为HTML后返回给用户，从而导致恶意代码执行</li><li><strong>反射性（服务器）</strong>，攻击者构建了特殊的URL，当服务器接受到请求后，从URL中获取数据，拼接到HTML后返回，从而导致恶意代码执行</li><li><strong>DOM型（浏览器）</strong>，攻击者构建了特殊的URL，用户打开网站后，js脚本从URL中获取数据，从而导致了恶意代码的执行</li></ul><h2 id="1-3-如何预防XSS"><a href="#1-3-如何预防XSS" class="headerlink" title="1.3 如何预防XSS"></a>1.3 如何预防XSS</h2><h3 id="1-3-1-恶意代码提交时过滤代码"><a href="#1-3-1-恶意代码提交时过滤代码" class="headerlink" title="1.3.1 恶意代码提交时过滤代码"></a>1.3.1 <strong>恶意代码提交时过滤代码</strong></h3><ul><li><p>检测输入的信息，进行前端过滤和后端过滤</p><p class="note note-danger"><strong>不推荐</strong><br/>    可能会引起乱码等意外的情况</p></li><li><p>数据存入数据库中时进行转义处理。比如把<code>&amp; &lt; &gt; &quot; &#39; /</code> 等字符转义掉</p><p class="note note-primary"><strong>推荐-服务端</strong><br/>    对于转义CSS内联样式，内敛JS，内联JSON等需要额外且复杂的转义策略</p></li></ul><h3 id="1-3-2-浏览器执行恶意代码时方案"><a href="#1-3-2-浏览器执行恶意代码时方案" class="headerlink" title="1.3.2 浏览器执行恶意代码时方案"></a>1.3.2 <strong>浏览器执行恶意代码时方案</strong></h3><ul><li><p>纯前端渲染。</p><ul><li>先让浏览器加载一个静态HTML，此HTML中不包含任何跟业务相关数据。</li><li>然后浏览器执行HTML的js脚本。</li><li>JS通过ajax加载业务数据，调用DOM API更新到页面上。在纯前端渲染中，会明确告诉浏览器，下面要设置的内容)是文本<code>(.innerText)</code>还是属性<code>(.setAttribute)</code>还是要是<code>(.style)</code>。这样浏览器不会被轻易欺骗。</li></ul><p class="note note-primary"><strong>推荐-浏览器</strong><br/>    简单设置无法防御DOM型XSS，需要使用.textContent, vue避免使用v-html等</p></li><li><p>白名单</p></li><li><p>限制输入内容长度。可以增加XSS攻击难度，但是没有从根本上解决问题<strong>（推荐）</strong></p></li><li><p>HTTP-only Cookie：禁止JS读取某些敏感Cookie，攻击者完成XSS注入之后也无法获取cookie<strong>（推荐）</strong></p></li><li><p>验证码：防止脚本冒充用户提交危险操作</p></li></ul><h1 id="2-Cross-Site-Request-Forgery"><a href="#2-Cross-Site-Request-Forgery" class="headerlink" title="2. Cross Site Request Forgery"></a>2. Cross Site Request Forgery</h1><h2 id="2-1-CSRF是什么"><a href="#2-1-CSRF是什么" class="headerlink" title="2.1 CSRF是什么"></a>2.1 CSRF是什么</h2><p>CSRF指跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器进行一些操作。这是利用了cookie会在同源请求中携带发送给服务器的特点，以实现用户冒充</p><h2 id="2-2-CSRF有哪些类型"><a href="#2-2-CSRF有哪些类型" class="headerlink" title="2.2 CSRF有哪些类型"></a>2.2 CSRF有哪些类型</h2><ul><li><strong>get型</strong>，比如一个img标签里构建了一个请求</li><li><strong>post型</strong>，隐藏的表单，用户进入页面的时候自动提交</li><li><strong>链接型</strong>，诱导用户点击一个链接，该链接会发送请求</li></ul><h2 id="2-3-如何预防CSRF"><a href="#2-3-如何预防CSRF" class="headerlink" title="2.3 如何预防CSRF"></a>2.3 如何预防CSRF</h2><h3 id="2-3-1-同源检测"><a href="#2-3-1-同源检测" class="headerlink" title="2.3.1 同源检测"></a>2.3.1 <strong>同源检测</strong></h3><p>使用Origin Header或者Referer Header确定源域名。</p><ul><li>O：大部分请求的Header中会携带Origin字段，如果存在即为同域。但也存在两种以外情况（IE11同源政策，302重定向）。</li><li>R：验证HTTP头里的Referer字段（其中包括了请求来源地址）</li></ul><h3 id="2-3-2-CSRF-Token验证"><a href="#2-3-2-CSRF-Token验证" class="headerlink" title="2.3.2 CSRF Token验证"></a>2.3.2 <strong>CSRF Token验证</strong></h3><p>使用Token进行身份验证，这样CSRF攻击无法获取，也就冒充不了。需要注意的是，Token是可以放在cookie中的，为防止CSRF，就不能放在cookie中了，应当放在session中。</p><p class="note note-primary"><strong>推荐</strong><br/>    安全性高，但是繁琐且消耗资源大。使用Token对单服务器在大流量的情况压力非常大。并且在会话中存储Token非常繁琐，而且不能在通用的拦截上统一处理所有的接口。</p><h3 id="2-3-3-双重cookie验证"><a href="#2-3-3-双重cookie验证" class="headerlink" title="2.3.3 双重cookie验证"></a>2.3.3 <strong>双重cookie验证</strong></h3><p>在用户访问网站页面时，</p><ul><li>想请求域名注入一个cookie，内容为随机字符串</li><li>在前端向后端发起请求时，取出cookie，并添加到URL的参数中</li><li>后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。</li></ul><p class="note note-primary"><strong>推荐</strong><br/>    但是在大型网站上安全性没有Token高</p><h3 id="2-3-4-使用samesite-cookie"><a href="#2-3-4-使用samesite-cookie" class="headerlink" title="2.3.4 使用samesite cookie"></a>2.3.4 使用<code>samesite cookie</code></h3><p>限制cookie不被第三方使用。将samesite设为strict，表示这个cookie在任何情况下都不可能作为第三方cookie。将其设置为Lax，如果是个GET请求，则这个cookie可以作为第三方cookie。</p><p class="note note-primary"><strong>推荐</strong><br/>    但不支持子域，所以子域没有办法与主域共享登录信息</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://juejin.cn/post/6844903685122703367#heading-29">前端安全系列（一）：如何防止XSS攻击？</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://juejin.cn/post/6844903689702866952#heading-32">前端安全系列之二：如何防止CSRF攻击？</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识hexo博客</title>
    <link href="/2021/06/06/%E5%88%9D%E8%AF%86hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/06/06/%E5%88%9D%E8%AF%86hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：Sean</p><p>前言 ：本文为如何搭建一个hexo静态博客，步骤非常细致，可以按照流程一步一步创建。文章也涵盖了一些创建博客时需要注意的问题以及我踩过的坑。 另外在配置环境和安装依赖时也可能会遇到很多问题，百度谷歌上对同类问题已有很多解答，本文不再赘述。</p></blockquote><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>博客部署到远端时创建的github仓库名格式为<code>username.github.io</code>，<strong>且username一定要与github用户名一致。</strong></li><li>windows操作系统要使用git bash，cmd无法执行一些终端命令</li></ol><h1 id="1-初建博客"><a href="#1-初建博客" class="headerlink" title="1. 初建博客"></a>1. 初建博客</h1><h2 id="1-1-配置环境、安装依赖"><a href="#1-1-配置环境、安装依赖" class="headerlink" title="1.1 配置环境、安装依赖"></a>1.1 配置环境、安装依赖</h2><ul><li>安装node</li><li>安装git</li><li>安装hexo，在终端中执行<code>npm i -g hexo-cli</code>全局安装</li></ul><h2 id="1-2-创建博客"><a href="#1-2-创建博客" class="headerlink" title="1.2 创建博客"></a>1.2 创建博客</h2><ul><li><p>进入到想要放置博客文件夹的位置，例如<code>cd D://</code></p></li><li><p>创建博客文件夹，<code>mkdir myBlog</code></p></li><li><p>进入blog文件夹，<code>cd myBlog</code></p></li><li><p>初始化博客，<code>hexo init</code></p></li><li><p>新建文章，<code>hexo new &quot;我的第一篇文章&quot;</code></p></li><li><p>使用markdown格式编辑这篇文章</p></li><li><p>生成博客，<code>hexo g</code></p></li><li><p>本地预览博客，<code>hexo s</code></p></li><li><p>清除旧数据，<code>hexo clean</code></p></li></ul><h1 id="2-部署博客到远端"><a href="#2-部署博客到远端" class="headerlink" title="2. 部署博客到远端"></a>2. 部署博客到远端</h1><ul><li><p>创建一个github仓库，仓库名格式为<code>username.github.io</code>，<strong>且username一定要与github用户名一致</strong>。</p></li><li><p>安装依赖<code>npm i --save hexo-deployer-git</code></p></li><li><p>配置blog文件夹里的<code>_config.yml</code>文件</p><p class="note note-warning">注意！type, repo, branch后面一定要有一个空格，否则会失败！</p><div class="code-wrapper"><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">deploy:type: git    repo: 你的github仓库地址    branch: main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>清除旧数据，<code>hexo clean</code></p></li><li><p>生成博客，<code>hexo g</code></p></li><li><p>部署到远端 <code>hexo d</code></p></li><li><p>访问博客地址在线预览，网址为<code>你的用户名.github.io</code></p></li></ul><h1 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h1><ul><li><p>在github上搜索<code>hexo-theme</code>找到喜欢的主题，推荐yilla, fluid-dev等</p></li><li><p>克隆主题。<code>git clone 目标主题的github地址 themes/xxx(主题的名字)</code></p></li><li><p>配置blog文件夹里的<code>_config.yml</code>文件</p><div class="code-wrapper"><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">language: zh-CNthemes: 你克隆的主题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></li><li><p>清除旧数据，<code>hexo clean</code></p></li><li><p>生成博客，<code>hexo g</code></p></li><li><p>部署到远端 <code>hexo d</code></p></li><li><p>访问博客地址在线预览，网址为<code>你的用户名.github.io</code></p></li><li></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.bilibili.com/video/BV1Yb411a7ty">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
